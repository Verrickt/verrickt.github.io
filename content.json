{"meta":{"title":"Melchior on CLR","subtitle":"Verrickt as a Programmer","description":"A programmer focus mainly on Microsoft Technologies","author":"Verrickt","url":"https://verrickt.github.io"},"pages":[],"posts":[{"title":"闭包，变量捕获与重入","slug":"Closure-and-re-entrance","date":"2018-03-08T11:59:20.000Z","updated":"2018-03-08T12:39:43.619Z","comments":true,"path":"2018/03/08/Closure-and-re-entrance/","link":"","permalink":"https://verrickt.github.io/2018/03/08/Closure-and-re-entrance/","excerpt":"","text":"公司的APP，在断网后进行一个10秒的倒计时操作，每秒钟都会尝试重新联网。当秒数到0时又重新开始计时，倒计时在用户退出程序或者连上网络结束。 按理说是个很简单的Case。QA却报过来个BUG，说APP状态由 联网-&gt;断网-&gt;联网-&gt;断网 变化后，倒计时的秒数变得不连续了 9 3 8 2 7 1 思考了一下，觉得应该是第一次倒计时的没有退出，第二次倒计时开始后两者都开始更新UI。 看了代码，果然是这样的 123456789101112131415161718192021222324void OnIPChanged()&#123; ShowOfflineUI();&#125;void ShowOfflineUI()&#123; Task.Factory.Start(delegate &#123; int i = 10; while(true) &#123; i = (i-1)%10; Invoke(UpdateCountDown(i))//update UI on UI thread try &#123; Thread.Sleep(TimeSpan.FromSeconds(1)) if(Connect()) &#123; break; &#125; &#125; &#125; &#125;)&#125; 说实话我不是很喜欢直接用Thread.Sleep来做操作，这样占用了一个线程忙等，浪费了资源。C#中一般采用基于Task的异步编程来做，这样不会浪费资源。Task提供的CancellationToken能够比较容易的实现取消。放到这个Case里，只要开始倒计时的时候取消上一次的倒计时就好了。 说干就干,我最喜欢用Task重写基于Thread的并发/异步了 12345678910111213141516171819202122232425262728TaskCancellationToken _cts;void OnIPChanged()&#123; ShowOfflineUI(); ShowOfflineUI();&#125;async Task ShowOfflineUI()&#123; _cts?.Cancel(); _cts = new CancellationToken(); await Task.Run( async ()=&gt; &#123; int i = 0; while(true) &#123; i = (i-1)%10; Invoke(UpdateCountDown(i)); await Task.Delay(TimeSpan.FromSeconds(1),_cts.Token); if(Connect()) &#123; break; &#125; &#125; &#125; );&#125; 为了验证方法的正确性，我特地在OnIPChanged()调用了两次ShowOfflineUI()。但是第一个Task并没有被取消。 分析问题写出了跟自己预期不一样的代码怎么办？当然是上Debugger了。在Debugger的火眼金睛下，我很快注意到了最明显的现象：在第二次调用ShowOfflineUI的时候，_cts.Cancel()并没有把第一个Task中的CancellationToken的IsCancellationRequest变为True。计算机科学里有句老话，那就是永远不要怀疑近30年内编译器的正确性。经过数十分钟的排(谷)查(歌)定位了问题的原因:两个Task引用的_cts是同一个。 原因剖析如果一个匿名函数引用了不属于他自己的局部变量，那么这个现象就称为闭包。因为这实在是太自然了所以我才没往这上面想。在给Task.Run中，我传入了一个Action类型的函数，它捕获了外部变量_cts。在函数中每次用到_cts的时候，被捕获的变量的值被重新计算，结果作为实际的值。而我的本意是让两个Task拥有不同的_cts，这样后边的Task就可以取消前边的Task了。明白了这些后就很好改了，在ShowOfflineUI里放一个局部变量，存储_cts的值，让匿名函数捕获这个局部变量就好了1234567891011121314151617181920212223async Task ShowOfflineUI()&#123; var local = _cts; local?.Cancel(); _cts = new CancellationToken(); await Task.Run( async ()=&gt; &#123; int i = 0; while(true) &#123; i = (i-1)%10; Invoke(UpdateCountDown(i)); await Task.Delay(TimeSpan.FromSeconds(1),local?.Token??CancellationToken.None); if(Connect()) &#123; break; &#125; &#125; &#125; );&#125; 有兴趣的朋友可以猜一猜这两段代码的结果，再运行验证一下 123456789101112131415161718public void NonLocal()&#123; List&lt;Action&gt; actions = new List&lt;Action&gt;(); for(int i=0 ;i&lt;10;i++) actions.Add(()=&gt;Console.WriteLine(i)); actions.ForEach(a=&gt;a());&#125;public void Local()&#123; List&lt;Action&gt; actions = new List&lt;Action&gt;(); for(int i=0 ;i&lt;10;i++) &#123; int j = i; actions.Add(()=&gt;Console.WriteLine(j)); &#125; actions.ForEach(a=&gt;a());&#125; 相信函数的名字已经告诉大家结果了。 最后祝你身体健康，再见","categories":[],"tags":[{"name":"TAP,Async/await,lambda","slug":"TAP-Async-await-lambda","permalink":"https://verrickt.github.io/tags/TAP-Async-await-lambda/"}]},{"title":"HTTPClient 踩坑记","slug":"httpclient-good-part-and-tipfalls","date":"2017-10-24T11:43:28.000Z","updated":"2017-10-25T13:57:17.740Z","comments":true,"path":"2017/10/24/httpclient-good-part-and-tipfalls/","link":"","permalink":"https://verrickt.github.io/2017/10/24/httpclient-good-part-and-tipfalls/","excerpt":"HttpClient是随着.Net framework 4.5一起发布的现代Http库。比起WebClient，HttpClient最大的优点就是加入了C#5中的async/await异步方法的支持。async/await的坑暂且不表，今天就来说一说这个HttpClient HttpClient的坑HttpClient实现了IDisposable接口，很多小伙伴一看到IDisposeable接口就纷纷把HttpClient套在了using里边 12345//bad httpclient usageusing(var client = new HttpClient())&#123; //do stuffs&#125; 这种用法是错误的.HttpClient在设计之初被设计为一个可重用的对象，它的生命周期应该与应用程序相一致.上述错误的用法每发起一个请求就会创建一个新的HttpClient，并且在收到回复之后立即把HttpClient dispose掉。众所周知TCP连接在真正断开之前会有几分钟处于CLOSE_WAIT状态。这个状态下TCP链接并没有真正断开。短时间内大量发出Http请求会使系统可用的端口急剧消耗。","text":"HttpClient是随着.Net framework 4.5一起发布的现代Http库。比起WebClient，HttpClient最大的优点就是加入了C#5中的async/await异步方法的支持。async/await的坑暂且不表，今天就来说一说这个HttpClient HttpClient的坑HttpClient实现了IDisposable接口，很多小伙伴一看到IDisposeable接口就纷纷把HttpClient套在了using里边 12345//bad httpclient usageusing(var client = new HttpClient())&#123; //do stuffs&#125; 这种用法是错误的.HttpClient在设计之初被设计为一个可重用的对象，它的生命周期应该与应用程序相一致.上述错误的用法每发起一个请求就会创建一个新的HttpClient，并且在收到回复之后立即把HttpClient dispose掉。众所周知TCP连接在真正断开之前会有几分钟处于CLOSE_WAIT状态。这个状态下TCP链接并没有真正断开。短时间内大量发出Http请求会使系统可用的端口急剧消耗。 MS的人推荐重用HttpClient以使其生命周期与应用相同 1234567891011//good httpclient usageclass GoodHttpClientSample&#123; private static readonly HttpClient client = new HttpClient(); public Task&lt;string&gt; GetStringAsync(string url) &#123; var resposne = await client.GetAsync(url).ConfigureAwait(false); return response.Content.ReadAsStringAsync(); &#125; &#125; HttpClient的优点踩过了坑我们再来说说他的好处。去掉async/await支持这个最大的有点，HttpClient的一个构造函数的重载接受一个HttpMessageHandler。这个重载很有意思。HttpMessageHandler可以在发出Http请求和接受Http回复时做出一些回应。.net framework里有一个类叫做DelegatingHandler，它继承了HttpMessageHandler。叫做DelegatingHandler是因为它有个类型为HttpMessageHandler的InnerHandler属性，因而可以把请求delegate给InnerHandler。通过这个DelegatingHandler我们可以请以实现像Java web里的filter chain一样的逻辑。 今天重构了公司的代码。公司现有的HttpManager提供了GET和POST两种Http动词的异步方法。在这些方法中还进行了日志记录和失败重试。日志记录和失败重试相关的代码非常重复，但是又无法写成一个函数。因此我把这部分逻辑抽出来做成了两个DelegatingHandler 12345678910111213141516171819202122232425class LogHandler:DelegatingHandler&#123; private readonly ILog _log; public LogHandler(ILog log,HttpMessageHandler handler):base(handler) &#123; _log = log; &#125; protected async override Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) &#123; try &#123; var begin = DateTime.Now; _log.I($\"&#123;request.Method&#125; -&gt;&#123;request.RequestUri&#125;\"); var response = await base.SendAsync(request,cancellationToken); var end = DateTime.Now; var diff = (end-begin).TotalMillseconds; _log.I($\"&#123;request.Method&#125; &lt;- &#123;response.Content.ReadAsStringAsync()&#125; cost&#123;diff&#125;ms\"); &#125; catch(Exception e) &#123; _log.E($\"&#123;request.Method&#125; -&gt;&#123;request.RequestUri&#125;,&#123;e&#125;\"); throw; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435class RetryHandler:DelegatingHandler&#123; protected async override Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request,CancellationToken cancellationToken) &#123; HttpResponseMessage response = null; for(int i=0;i&lt;=_retryTimes,i++) &#123; try &#123; response = await base.SendAsync(request,cancellationToken); return response; &#125; catch(Exception) &#123; if(i==_retryTimes) &#123; throw; &#125; &#125; //make compiler happy. return response; &#125; &#125; private readonly int _retryTimes = 0; public RetryHandler(int retryTimes,HttpMessageHandler handler):base(handler) &#123; if(retryTimes&lt;0) &#123; throw new ArgumentOutOfRangeException(nameof(retryTimes)); &#125; _retryTimes = retryTimes; &#125;&#125; HttpClientHandler是个真正实现HttpClient逻辑的HttpMessageHandler。因此，我们只要保证最内部的Handler时HttpClientHandler就OK了。 1234private static readonly ILog _log;private static readonly HttpClient _client = new HttpClient(new RetryHandler(3,new LogHandler(_log,new HttpClientHandler()))); 需要注意的是，如果HttpHandler没有返回HttpResponseMessage,对应的异步方法会在运行时抛出InvalidOperationException 重构之后整个Http封装类的代码行数从400行减少到了120行左右，可读性和可维护性提升显著。 Further readingFUN WITH THE HTTPCLIENT PIPELINE YOU’RE USING HTTPCLIENT WRONG AND IT IS DESTABILIZING YOUR SOFTWARE Do HttpClient and HttpClientHandler have to be disposed?","categories":[],"tags":[{"name":"HttpClient","slug":"HttpClient","permalink":"https://verrickt.github.io/tags/HttpClient/"},{"name":"C#","slug":"C","permalink":"https://verrickt.github.io/tags/C/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-09-18T13:40:28.284Z","updated":"2017-09-18T13:40:28.285Z","comments":true,"path":"2017/09/18/hello-world/","link":"","permalink":"https://verrickt.github.io/2017/09/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}