{"meta":{"title":"Melchior on CLR","subtitle":"Verrickt as a Programmer","description":"A programmer focus mainly on Microsoft Technologies","author":"Verrickt","url":"https://verrickt.github.io"},"pages":[],"posts":[{"title":"Build a (partial) self-contained WPF application","slug":"self-contained-wpf-application","date":"2018-07-31T14:43:47.000Z","updated":"2018-08-02T15:04:55.513Z","comments":true,"path":"2018/07/31/self-contained-wpf-application/","link":"","permalink":"https://verrickt.github.io/2018/07/31/self-contained-wpf-application/","excerpt":"巨人的肩膀新事物的产生总是与老事物有千丝万缕的联系。或是从中得到启发，或是对其全面改良。新事物的源头通常可以追溯到很久远的一些概念上。因此有了「站在巨人的肩膀上」 这样的说法。在程序设计里面，「巨人们的肩膀」 就是我们的应用程序使用的库了。踩在这些「巨人」们的肩膀上我们的程序才得以重见天日；为了实现一个库，有时候会使用到其他的库。我们所依赖的「巨人」又踩在了其他「巨人」的肩膀上，把依赖关系变成了树状结构，我们的程序处在根节点。 扯远了:)","text":"巨人的肩膀新事物的产生总是与老事物有千丝万缕的联系。或是从中得到启发，或是对其全面改良。新事物的源头通常可以追溯到很久远的一些概念上。因此有了「站在巨人的肩膀上」 这样的说法。在程序设计里面，「巨人们的肩膀」 就是我们的应用程序使用的库了。踩在这些「巨人」们的肩膀上我们的程序才得以重见天日；为了实现一个库，有时候会使用到其他的库。我们所依赖的「巨人」又踩在了其他「巨人」的肩膀上，把依赖关系变成了树状结构，我们的程序处在根节点。 扯远了:) 开发的时候有包管理工具帮我们管理依赖，而到了分发的时候，需要一个容器把我们的程序和它的依赖项一起分发。这就需要用到安装程序。最终用户只要拿到安装程序，运行安装，由安装程序去操心依赖项到底应该放在哪。 人是懒惰的动物，从用户发现软件到真正用上软件之间，每多一个步骤都会让损失一批潜在用户。而现在随着手机的流行，用户已经不想安装了。他们只想下载「软件」，双击就能直接运行。至于什么安装路径，UAC权限之类的用户才不想操心呢。 这就要求我们的程序要将安装这个过程隐藏起来。在用户看不到的情况下部署自己的依赖项。这样的程序在英文里被称为 self-contained self-containedadjective (of a thing) complete, or having all that is needed, in itself. (of a person) quiet and independent; not depending on or influenced by others. 这几天我们也有了将最终程序self-contain化的需求。终于可以合理的抛弃MFC写的Installer了😁 Self-contained in .NET.NET在设计之初只是想提高Windows程序员的开发效率，顺便解决一下DLL Hell。至于应用分发根本就不再日程上。就算真的考虑过，也一定会采用动态链接的方式。因为当时的硬盘还是很贵滴。 总之，.NET就这样决定采用动态链接了。.NET里的几个基本概念也都与动态链接脱不开关系： 程序集)是.NET世界里最常见的分发单元。程序集有独立的版本号。在引用其他程序集的时候，需要显式指明对应的版本。这样，相同名字不同版本的程序集就可以被区别开，以此为基础就解决Dll hell的问题。CLR在运行的时候以一套复杂的规则试图加载程序的依赖项。 看起来似乎.NET与静态链接无缘了。不过也有好消息，在Build 2018开发者大会上，微软宣布现有的桌面程序可以在明年推出的.Net core 3上选择与运行时静态链接在一起，将整个程序变为单一的可执行文件。 Side-by-side and App-local Deployment For cases where the maximum isolation is required, you can deploy .NET Core with your application. We’re working on new build tools that will bundle your app and .NET Core together as in a single executable, as a new option. We’ve had requests for deployment options like this for many years, but were never able to deliver those with the .NET Framework. The much more modular architecture used by .NET Core makes these flexible deployment options possible. .Net Core 3.0的推出时间是明年，我们显然不能等到那个时候。为了实现需求，先向搜索引擎求助吧。 静态链接静态链接将依赖项打包进我们的程序，生成单一的二进制文件。这是个很直观的切入点。以C# static link为关键词，发现有几个同类型的工具。例如ILMerge。在.NET的世界中，源代码经过编译后产生的程序集里存储的并不是机器代码而是一种叫MSIL的中间代码。程序集由CLR加载后被JIT即时编译为机器码。 ILMerge之类的工具工作在IL层面。它们将不同程序集的IL代码粘合起来，生成单一的程序集。 听起来是不是很美好？如果你写个小demo的话会发现确实很好用。但是ILMerge无法对WPF中的XAML资源进行改写。程序挂在运行时。 内嵌资源.NET中的程序集有资源的概念。任何文件都能以资源的形式嵌入进程序集。另一个思路是是把依赖项当作资源嵌进我们的主程序。只要能在运行时把它们暴露给CLR，就能实现self-contain。先来看看API： Assembly.GetManifestResourceStream(string name): 12//Loads the specified manifest resource from this assembly.public virtual System.IO.Stream GetManifestResourceStream (Type type, string name) AppDomain.Load(Byte[]): 12//Loads the Assembly with a common object file format (COFF) based image containing an emitted Assembly.public System.Reflection.Assembly Load (byte[] rawAssembly); AppDomain.AssemblyResolve 12//Occurs when the resolution of an assembly fails.public event ResolveEventHandler AssemblyResolve; 我们把依赖项嵌入到程序内部后，CLR找不到引用的程序集的时候就会触发AppDomain.AssemblyResolve事件。我们可以在这里拿到依赖的AssemblyName,Assembly.GetManifestResourceStream(string name)得到包含依赖项的的stream，把stream的内容读出来放到byte[]里，调用AppDomain.Load(Byte[])将程序集加载。 大致过程走得通，不过有点麻烦。hardcode依赖的名字后，以后添加新依赖项还要更改hardcode的名字。毕竟程序员也是人，也想偷懒。这些活最好自动化。要是能和VS里的编译结合起来就更好了🤤 你别说，还真有这样的工具。Fody可以对.NET程序集做多种操作。Costura是Fody的一个扩展，专门用来将依赖嵌入成资源。Fody与VS的完美集成，编译完成后自动开始操作。Nuget安装完Fody和Costura后，如果解决方案根路径下没有FodyWeavers.xml则新建它。把内容替换为 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;Weavers&gt; &lt;Costura/&gt;&lt;/Weavers&gt;` 就完事了。太易用了。我做了测试，WPF和控制台应用都可以。看文档，它还支持.NET Core。 Dependencies of my dependencies, is not my dependenciesILMerge也好，Fody也好，它们解决的都是应用程序所依赖库的问题。而我们的程序之所以叫.NET程序，是因为它依赖.NET Framework。如果要做到fully-self-contained的话，我们还需要把.NET Framework也塞进去。这就意味这我们需要一个不依赖.NET Framework的程序来释放.NET Framework和我们的应用程序。这其实就是重新发明安装程序了。退一步说，就算我们真的把.NET Framework打包进去了，因为.NET Framework的安装过程比较耗时，用户在点了按钮后几秒钟如果UI还没出来可能会认为我们的程序有问题。因此，把程序和.NET Framework一起分发的事情就交给愿意折腾的同学们了。我还是期待下.NET Core 3.0吧。 总结如果你的程序是WPF程序，请使用Fody.Costura； 如果你的程序不是WPF程序，那么可以任选ILMerge和Fody.Costura的一个。 如果你的程序需要与.NET Framework一起分发，请在处理主程序后使用支持静默安装的Installer将主程序与.NET运行时一起打包。 或者等.Net Core 3.0发布 Reference .Net Core 3.0 - blogs.msdn.microsoft.com How the Runtime Locates Assemblies - docs.microsoft.com Fody - github.com Costura - github.com .NET Framework deployment guide for developers - docs.microsoft.com","categories":[],"tags":[{"name":"WPF","slug":"WPF","permalink":"https://verrickt.github.io/tags/WPF/"},{"name":".Net Framework","slug":"Net-Framework","permalink":"https://verrickt.github.io/tags/Net-Framework/"}]},{"title":"引用类型的开销","slug":"overhead-of-objects","date":"2018-07-19T12:26:05.000Z","updated":"2018-08-02T15:04:16.447Z","comments":true,"path":"2018/07/19/overhead-of-objects/","link":"","permalink":"https://verrickt.github.io/2018/07/19/overhead-of-objects/","excerpt":"值类型与引用类型C#中的类型分为引用类型和值类型。使用struct或enum关键字修饰的类型定义是值类型，使用class或delegate关键字修饰的类型是引用类型。引用类型和值类型各有限制，分别适用于不同的场景。不同于C++，C#中的值类型只能分配在栈上*1，引用类型只能分配在GC堆上。C#中的GC是精确式GC，这就对GC堆上的指针有了一些要求。这是引用类型有开销的原因之一。 Sync block index 与 Type object pointer读过C# vir CLR的同学会知道，引用类型的开销是Sync blockindex和Type object pointer。他们的长度是都是一个字长。即在32位CLR上是4字节，在64位CLR上是8字节。Sync block index在CLR中是用于实现lock,Monitor等线程同步原语，Type object pointer是指向当前对象运行时类型信息的一个指针。Sync block index与Type object pointer只在CLR层面存在，对C#程序来说是透明的。但是CLR将它们暴封装后露C#，例如线程同步原语和反射API。","text":"值类型与引用类型C#中的类型分为引用类型和值类型。使用struct或enum关键字修饰的类型定义是值类型，使用class或delegate关键字修饰的类型是引用类型。引用类型和值类型各有限制，分别适用于不同的场景。不同于C++，C#中的值类型只能分配在栈上*1，引用类型只能分配在GC堆上。C#中的GC是精确式GC，这就对GC堆上的指针有了一些要求。这是引用类型有开销的原因之一。 Sync block index 与 Type object pointer读过C# vir CLR的同学会知道，引用类型的开销是Sync blockindex和Type object pointer。他们的长度是都是一个字长。即在32位CLR上是4字节，在64位CLR上是8字节。Sync block index在CLR中是用于实现lock,Monitor等线程同步原语，Type object pointer是指向当前对象运行时类型信息的一个指针。Sync block index与Type object pointer只在CLR层面存在，对C#程序来说是透明的。但是CLR将它们暴封装后露C#，例如线程同步原语和反射API。 特殊的类型-数组C#中绝大部分类型的大小在编译期就可以确定，只要把对应的成员的大小相加即可1SizeOf(T) = T.GetFields.Select(f=&gt;f.IsClass?WordSize:Sizeof(f)).Sum(); 数组是个很特殊的存在，特殊在它的大小是与元素的类型和数量有关。数组的内存布局包含了所有的元素。(另一个这样的类型是string)。byte[4]和byte[3]的类型都是byte[]，然而它们的大小却不一样。我们这次就好仔细观察下数组 使用WinDBGWinDBG是Windows下常用的Debugger。虽然是以调试非托管代码设计，但是加上相关的插件以后也可以用来调试托管代码。SOS.dll是一个提供托管代码调试支持的的插件。它同时支持CLR和CoreCLR。 安装好WinDBG后，就可以开始调试了。简单起见，这里使用如下代码。1234567891011121314151617namespace SOSFromEE&#123; class Program &#123; const int Length = 10; static void Main(string[] args) &#123; var ints = Enumerable.Range(1, Length).ToArray(); var strs = ints.Select(i =&gt; i.ToString()).ToArray(); Console.ReadLine(); GC.KeepAlive(ints); GC.KeepAlive(strs); Console.Read(); &#125; &#125;&#125; 在WinDBG中选择Launch对应的可执行程序即可。在第一个断点时CLR还没有加载，我们继续让程序运行，等到不再出现ModLoad相关的提示时就可以让程序暂停了。我们在这时加载SOS扩展。 1.loadby sos CLRNameHere sos后跟的是CLR的名称 CLR2.0(.Net framework 3.5及以前)是mscorwks CLR4.0(.Net framework 4.0及以后)是clr .net core是 coreclr 加载模块的过程中需要从微软的服务器上下载相关的pdb文件。由于你懂的原因需要很长时间 CLR2.0 下的数组我们首先在32位的CLR2.0下观察。 首先使用.loadby sos mscorwks加载SOS扩展模块。 !dumpheap -type TypeNameHere命令可以查看当前托管堆上类型名为TypeNameHere的对象。 System.String[]我们先看看String[]都有哪些: 123456789100:006&gt; !dumpheap -type System.String[] Address MT Size03591390 78ae46e4 80 ..........................total 17 objectsStatistics: MT Count TotalSize Class Name78ae46e4 17 676 System.Object[]Total 17 objects Address显示的是对象在托管堆中的地址，Method Table就是上文中说的Type object pointer了。 我们查看下位于地址03591390的String[]:1234567891011121314151617181920212223240:006&gt; !dumparray 03591390Name: System.String[]MethodTable: 78ae46e4EEClass: 788cda74Size: 80(0x50) bytesArray: Rank 1, Number of elements 16, Type CLASSElement Methodtable: 78b10f14[0] 035911c8[1] 03591250[2] null[3] null[4] null[5] null[6] null[7] null[8] null[9] null[10] null[11] null[12] null[13] null[14] null[15] null 可以看到这个数组一共有16个元素，元素的类型是string。 我们再来看看03591390位置的内存布局 12345670:006&gt; dd 03591390 -0x40359138c 00000000 78ae46e4 00000010 78b10f140359139c 035911c8 03591250 00000000 00000000035913ac 00000000 00000000 00000000 00000000035913bc 00000000 00000000 00000000 00000000035913cc 00000000 00000000 00000000 00000000 dd 03591390 -0x4告诉WinDBG从03591390向前偏移4个字节的位置开始展示内存。之所以向前偏移4个字节是为了展示引用类型的开销。0359138c位置的值00000000是Sync block index，位于03591390的78ae46e4看起来有点摸不着头脑，在WinDBG的输出中查找后发现是System.String[]的MethodTable。12Name: System.String[]MethodTable: 78ae46e4 MethodTable是CLR级别的概念，对应到这里就是Type Object Pointer。GC堆上的对象往前偏４字节就能得到Sync block index，接下来是对象的Type object pointer。为了叙述方便，下文统称为对象头:) 由此推测，对象头长度是两个字长。起始位置为当前指针的位置往前偏移一个字长。有兴趣的同学可以在64位CLR上自行验证。 数组的长度是16(0x10)，地址03591395的值就是它。 地址03591388的78b10f14不知道是什么。没关系，CTRF+F查找后发现它在上文出现过。 1Element Methodtable: 78b10f14 应该是String的Method table。 dump一下System.String:12340:006&gt; !dumpheap -type System.String MT Count TotalSize Class Name78b10f14 154 6224 System.String 看来猜得没错。总结一下，引用类型的数组有4字长的开销，分别是2字长的对象头，1字长的长度，1字长的元素类型指针 接下来看看值类型数组的布局 System.Int32[]老样子，首先先找到堆上的Int32[]. 1234567890:006&gt; !dumpheap -type System.Int32[] Address MT Size03591e50 78b130b0 296 ................................total 18 objectsStatistics: MT Count TotalSize Class Name78b130b0 18 1440 System.Int32[]Total 18 objects dump一下相关属性 1234567!dumparray 03591e50 Name: System.Int32[]MethodTable: 78b130b0EEClass: 788ce6a8Size: 296(0x128) bytesArray: Rank 1, Number of elements 71, Type Int32Element Methodtable: 78b13160 查看内存布局 1234567890:006&gt; dd 03591e50 -0x403591e4c 00000000 78b130b0 00000047 0000000003591e5c 00000000 00000000 00000000 0000000003591e6c 00000000 00000000 00000000 0000000003591e7c 00000000 00000000 00000000 0000000003591e8c 00000000 00000000 00000000 0000000003591e9c 00000000 00000000 00000000 0000000003591eac 00000000 00000000 00000000 0000000003591ebc 00000000 00000000 00000000 00000000 首先Int32[]也有对象头和长度的开销，但是却没有元素类型指针的开销。 有心的同学可能已经发现了，Int32[]明确指出了元素的类型，而String[]却没有。 123456!dumparray 03591390Name: System.String[]MethodTable: 78ae46e4EEClass: 788cda74Size: 80(0x50) bytesArray: Rank 1, Number of elements 16, Type *CLASS* 123456!dumparray 03591e50 Name: System.Int32[]MethodTable: 78b130b0EEClass: 788ce6a8Size: 296(0x128) bytesArray: Rank 1, Number of elements 71, Type *Int32* String[]的Type是个CLASS而不是String，难道说System.String[]是个’假的’的字符串数组？ …. …. …. 恭喜你猜对了。使用!objsize命令发现String[]是个带了层皮的Object[]1234!objsize 03591e50 sizeof(03591e50) = 296 ( 0x128) bytes (System.Int32[])0:006&gt; !objsize 03591390 sizeof(03591390) = 392 ( 0x188) bytes (System.Object[]) C# in depth中对泛型有这样的描述 对于一个泛型类MyGeneric&lt;T&gt;，对于T的是引用类型的情况，JIT只会为其生成一份代码;对于T是值类型的情况，则为每一个不同的T生成各自的代码。其中的原因是，在JIT运行时，指针的长度总是固定的，因而可以共用一套代码相同的代码。而值类型的长度是不确定的，因此需要为每个值类型单独生成代码。 这里可能也是相同的原因吧。指针的长度相同，因而才需要储存元素的类型指针，实现类型检查。而值类型的代码不共用，所以不需要储存元素的类型指针。 本来到已经可以结束了，可是我在32位的CLR4.0观察到的结果却不太一样。 CLR 4.0下的数组与CLR 2.0不同，CLR 4.0下加载SOS的名字是clr .loadby sos clr System.String[]首先dumpheap： 123456780:006&gt; !dumpheap -type System.String[] Address MT Size02531590 6979dfe0 84 ...........................Statistics: MT Count TotalSize Class Name6979dfe0 24 912 System.String[]Total 24 objects 然后是dumparray:1234567Name: System.String[]MethodTable: 6979dfe0EEClass: 69374b80Size: 84(0x54) bytesArray: Rank 1, Number of elements 18, Type CLASSElement Methodtable: 6979d488[0] 02531254 最后dd:12345670:006&gt; dd 02531590 -0x40253158c 00000000 6979dfe0 00000012 025312540253159c 025312d8 00000000 00000000 02531568025315ac 00000000 00000000 00000000 00000000025315bc 00000000 00000000 00000000 00000000025315cc 00000000 00000000 00000000 00000000025315dc 00000000 00000000 位于02531598的值02531254是第一个元素的值而不是String的Method Table!12345!dumpheap -type StringStatistics: MT Count TotalSize Class Name6979d488 193 5932 System.StringTotal 224 objects CLR 4.0把Method Table去掉了？ 经过简单的算术，确实是这样的18个元素，占据空间18*4=72。 对象头和数组大小占据2*4+4=12 84=72+12，跟dumparray出来的值一样。(有兴趣的同学根据上文中CLR2.0的数据计算下) !objsize也确认了我们的猜测120:006&gt; !objsize 02531590sizeof(02531590) = 428 (0x1ac) bytes (System.String[]) System.Int32[]!dumpheap:123456780:006&gt; !dumpheap -type System.Int32[] Address MT Size02531f1c 6979f2a0 300 .............................. Statistics: MT Count TotalSize Class Name6979f2a0 20 844 System.Int32[]Total 20 objects !dumparray:1234567890:006&gt; !dumparray 02531f1c Name: System.Int32[]MethodTable: 6979f2a0EEClass: 693752d8Size: 300(0x12c) bytesArray: Rank 1, Number of elements 72, Type Int32Element Methodtable: 6979f2dc[0] 02531f24[1] 02531f28 dd:1234567890:006&gt; dd 02531f1c -0x402531f18 00000000 6979f2a0 00000048 0000000302531f28 00000007 0000000b 00000011 0000001702531f38 0000001d 00000025 0000002f 0000003b02531f48 00000047 00000059 0000006b 0000008302531f58 000000a3 000000c5 000000ef 0000012502531f68 00000161 000001af 00000209 0000027702531f78 000002f9 00000397 0000044f 0000052f02531f88 0000063d 0000078b 0000091d 00000af1 值类型数组倒是没有什么变化。 总结C#中引用类型有2个字长的对象头开销。分别是Sync block index和Type Object Pointer。数组是特殊的类型，它的大小与包含的元素相关，因此具有额外的开销。 在CLR 2.0下 引用类型的数组包含额外的2字长的开销。分别是长度和元素的类型指针 值类型的数组包含长度的额外开销开销。大小是一个字长。 在CLR 4.0和CoreCLR中 引用类型和值类型的数组包含长度的额外开销开销。大小是一个字长。 限于篇幅，CoreCLR的情况不再赘述，还请读者自行验证。 /*其实本来看到Stackoverflow的回答只是想自己验证下的，但是自己动手的结果和答案里提到的不太一样，查了原因发现答案里用的是CLR2.0，我自己用的是CLR4.0。这就挖出来了CLR实现的更改。CoreCLR里使用的是CLR4.0里的规则。目前还不清楚MS为何要改实现*/ 参考 Overhead of a .NET array? SOS.dll (SOS Debugging Extension)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://verrickt.github.io/tags/C/"},{"name":"reference type","slug":"reference-type","permalink":"https://verrickt.github.io/tags/reference-type/"},{"name":"overhead","slug":"overhead","permalink":"https://verrickt.github.io/tags/overhead/"}]},{"title":"面向抽象编程","slug":"program-towards-abstractions","date":"2018-07-12T13:56:26.000Z","updated":"2018-07-12T15:12:46.311Z","comments":true,"path":"2018/07/12/program-towards-abstractions/","link":"","permalink":"https://verrickt.github.io/2018/07/12/program-towards-abstractions/","excerpt":"Preface说来惭愧，直到近几天才明白了一点面向对象设计的。给我带来启发的是SOLID中的D，它代表Dependency Inversion（依赖反转）。尽管写/背定义很无聊，但我还是想写一下依赖反转的核心 上层模块不应该依赖下层模块，他们都应该依赖抽象 Talk is cheap, show me the code最近在写一个音乐电台应用，采用服务端、客户端的方式实现。在服务端，用户可以指定一个路径，程序根据这个路径生成播放列表。 需求服务器是一个一旦开起来就不会轻易关闭的程序，我希望播放列表能够自动刷新。这样当用户添加或删除了某首音乐后不用重启服务器就可以反映变化。考虑到易用性，应该支持由路径直接生成播放列表。歌曲是有封面等其他信息的，要满足这些信息的可定制化，程序也支持由配置文件指定的播放列表。","text":"Preface说来惭愧，直到近几天才明白了一点面向对象设计的。给我带来启发的是SOLID中的D，它代表Dependency Inversion（依赖反转）。尽管写/背定义很无聊，但我还是想写一下依赖反转的核心 上层模块不应该依赖下层模块，他们都应该依赖抽象 Talk is cheap, show me the code最近在写一个音乐电台应用，采用服务端、客户端的方式实现。在服务端，用户可以指定一个路径，程序根据这个路径生成播放列表。 需求服务器是一个一旦开起来就不会轻易关闭的程序，我希望播放列表能够自动刷新。这样当用户添加或删除了某首音乐后不用重启服务器就可以反映变化。考虑到易用性，应该支持由路径直接生成播放列表。歌曲是有封面等其他信息的，要满足这些信息的可定制化，程序也支持由配置文件指定的播放列表。 现有代码123456789internal class PlaylistManager&#123; public IReadonlyList&lt;Song&gt; AllSong =&gt; _backLogs.AsReadOnly(); private readonly List&lt;Song&gt; _backLogs; public PlaylistManager(IEnumerable&lt;Song&gt; backlog) &#123; _backLogs = new List&lt;Song&gt;(backlog); &#125;&#125; 现有代码中构造函数的IEnumerable\\参数指定了播放列表，可是刷新却需要外部的支持：基于路径的刷新和基于配置文件的刷新是完全不一样的。我完全可以把这两个刷新都放到PlaylistManager里，根据生成播放列表的类型决定调用那个版本。这样就把PlaylistManager完全和列表生成的逻辑绑死在一起了，如果以后要在加一个新的生成方式就还要修改PlaylistManager的代码，尽管它跟PlaylistManager并无关系 修改思路如果我们将生成播放列表这一行为抽象为接口IPlaylistProvider的话，PlaylistManager就可以完全跟这部分逻辑分开了 123456789101112131415161718192021222324public interface IPlaylistProvider&#123; IReadonlyList&lt;Song&gt; AllSongs &#123; get; &#125; void Refresh();&#125;internal class PlaylistManager&#123; public IReadonlyList&lt;Song&gt; AllSong =&gt; _backLogs.AsReadOnly(); private readonly List&lt;Song&gt; _backLogs; private readonly IPlaylistProvider _provider; public PlaylistManager(IPlaylistProvider provider) &#123; _provider = provider; _backLogs = new List&lt;Song&gt;(_provider.AllSongs); &#125; internal void Refresh() &#123; Refresh(); _backLogs.Clear(); _backLogs.AddRange(_provider.AllSongs); &#125;&#125; 我们可以分别实现基于路径和配置文件的IPlaylistProvider 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class FileSystemProvider : IPlaylistProvider&#123; public FileSystemProvider(string path,bool recursive) &#123; if (!Directory.Exists(path)) &#123; throw new ArgumentException($\"&#123;path&#125; is not a directory\"); &#125; Path = path; Recursive = recursive; _songs = ReadSongs(); &#125; static readonly string[] MusicExtension = new[] &#123;\".mp3\",\".wma\" &#125;; private List&lt;Song&gt; ReadSongs() &#123; var song = new List&lt;Song&gt;(); var dir = new DirectoryInfo(Path); var files = dir.GetFiles().Where(i =&gt; MusicExtension.Contains(i.Extension)); song.AddRange(files.Select(f =&gt; new Song() &#123; FilePath = f.FullName, Title = f.Name, &#125;)); return song; &#125; public IReadOnlyList&lt;Song&gt; AllSongs =&gt; _songs.AsReadOnly(); public string Path &#123; get; &#125; public bool Recursive &#123; get; &#125; private List&lt;Song&gt; _songs; public void Refresh() &#123; _songs = ReadSongs(); &#125;&#125;public class JsonPlaylistProvider : IPlaylistProvider&#123; public JsonPlaylistProvider(string configPath) &#123; _songs = ReadSongs(); ConfigPath = configPath; if (!File.Exists(ConfigPath)) &#123; throw new ArgumentException($\"Can't find config file at &#123;ConfigPath&#125;\"); &#125; ReadSongs(); &#125; private List&lt;Song&gt; ReadSongs() &#123; var json = File.ReadAllText(ConfigPath); return JsonConvert.DeserializeObject&lt;List&lt;Song&gt;&gt;(json)??new List&lt;Song&gt;(); &#125; private List&lt;Song&gt; _songs; public string ConfigPath &#123; get; &#125; public IReadOnlyList&lt;Song&gt; AllSongs =&gt; _songs.AsReadOnly(); public void Refresh() &#123; ReadSongs(); &#125;&#125; 这个例子中，PlaylistManager不依赖FileSystemProvider和JsonPlaylistProvider，它们三者都依赖于IPlaylistProvider这一接口。代码的可读性和可维护性相比于把刷新的逻辑放在PlaylistManager里高了好多 这里体现了依赖反转的原则： 上层模块不应该依赖下层模块，它们都应该依赖与抽象 如果你也像曾经的我一样，熟记面向对象的各种原理却不明白其中的道理，不妨试试用SOLID的方法论组织自己的代码，相信这会加深你对OOP的理解。","categories":[],"tags":[{"name":"面向对象编程","slug":"面向对象编程","permalink":"https://verrickt.github.io/tags/面向对象编程/"},{"name":"SOLID","slug":"SOLID","permalink":"https://verrickt.github.io/tags/SOLID/"}]},{"title":"一次愉(dan)快(teng)的捉虫经历","slug":"an-awful-debugging","date":"2018-05-21T13:03:59.000Z","updated":"2018-08-03T02:37:35.771Z","comments":true,"path":"2018/05/21/an-awful-debugging/","link":"","permalink":"https://verrickt.github.io/2018/05/21/an-awful-debugging/","excerpt":"废话缺陷是是在软件开发过程中经常遇到的问题。它是如此常见以在开发者的圈子中衍生出“It’s not a bug,it’s a feature”这样的段子。快速定位、解决问题是优秀开发者必备的素质。 问题公司有个基于WPF的项目，上线在即。几个开发在deadline之前总算把功能赶完了，这是接到QA报了一个BUG，说程序在Win8.1上Out of memory崩溃了。得到消息后立刻跑过去尝试重现，得到了这样的调用栈：","text":"废话缺陷是是在软件开发过程中经常遇到的问题。它是如此常见以在开发者的圈子中衍生出“It’s not a bug,it’s a feature”这样的段子。快速定位、解决问题是优秀开发者必备的素质。 问题公司有个基于WPF的项目，上线在即。几个开发在deadline之前总算把功能赶完了，这是接到QA报了一个BUG，说程序在Win8.1上Out of memory崩溃了。得到消息后立刻跑过去尝试重现，得到了这样的调用栈： System.OutOfMemoryException: Insufficient memory to continue the execution of the program. at System.Windows.Media.MediaContext.NotifyPartitionIsZombie(Int32 failureCode) at System.Windows.Media.MediaContext.NotifyChannelMessage() at System.Windows.Interop.HwndTarget.HandleMessage(Int32 msg, IntPtr wparam, IntPtr lparam) at System.Windows.Interop.HwndSource.HwndTargetFilterMessage(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean&amp; handled) at MS.Win32.HwndWrapper.WndProc(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam, Boolean&amp; handled) at MS.Win32.HwndSubclass.DispatcherCallbackOperation(Object o) at System.Windows.Threading.ExceptionWrapper.InternalRealCall(Delegate callback, Object args, Boolean isSingleParameter) at System.Windows.Threading.ExceptionWrapper.TryCatchWhen(Object source, Delegate callback, Object args, Boolean isSingleParameter, Delegate catchHandler) at System.Windows.Threading.Dispatcher.WrappedInvoke(Delegate callback, Object args, Boolean isSingleParameter, Delegate catchHandler) at System.Windows.Threading.Dispatcher.InvokeImpl(DispatcherPriority priority, TimeSpan timeout, Delegate method, Object args, Boolean isSingleParameter) at System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority priority, Delegate method, Object arg) at MS.Win32.HwndSubclass.SubclassWndProc(IntPtr hwnd, Int32 msg, IntPtr wParam, IntPtr lParam) at MS.Win32.UnsafeNativeMethods.DispatchMessage(MSG&amp; msg) at System.Windows.Threading.Dispatcher.PushFrameImpl(DispatcherFrame frame) at System.Windows.Threading.Dispatcher.PushFrame(DispatcherFrame frame) at System.Windows.Threading.Dispatcher.Run() 第一次尝试看见Hwnd，初步怀疑是程序里自定义的消息循环的问题。心想以前的版本里消息循环也没搞出来过OOM，我把消息循环相关的代码注释掉。重新部署后问题依旧。经同事提醒，开始在内部发布的版本里寻找能正常的版本。二分很快就找到了能正常使用的版本A和A之后不能正常使用的版本B。我确实没记错。能稳定重现后打算从异常本身入手。一番搜索后找到了微软的一篇博客 … WPF render thread encountered some fatal error … Most of the time, a failure occurs when calling into DirectX/D3D … When a failure is detected, The render thread will attempt to map the failure it receives to an appropriate managed exception. The render thread only synchronizes with the UI thread in a few locations …The most common locations when they synchronize are … or as a result of the UI thread handling a “channel” message from DirectX. If a render thread failure manifests as a System.OutOfMemoryException, then the likelihood is that the render thread was a victim of the process exhausting some resource .The exhausted resource is most often available/contiguous virtual address space … It might be a situation where sometimes the WPF render thread is the victim of the resource exhaustion … Hmm, 错误发生在DirectX渲染层面，这个BUG越来越有意思了。WPF里基本不会接触到直接跟渲染相关的东西。不过既然找到了版本A和B，那就从代码层面入手好了。打开版本控制软件，打算对比下改动过的代码。这是发现一个十分尴尬的问题：B版本没有打tag。按照公司的开发流程，每次出版本之前都需要在对应的提交上打tag。带着不按流程办事的负罪感，我在宇宙第一集成开发环境Visual Studio中打开了控制项目版本的文件，顺利找到了对应B版本的那个commit。根据diff，两个版本之间改的代码不算很多，排除掉无关的文件就只剩下UI了。这时忽然想起来程序起来时首先进入的是登陆页，还不确定是不是只有登陆页面才有问题。改下逻辑直接进入主界面发现问题消失了。运气不错，一下子就找到了根源。尝试把A版本登陆界面的代码直接覆盖到B版本，程序挂了。两次的结果互相冲突了，嗯，还是从登陆页面入手吧。我开始按照二分的原则开始删除代码，很快找到了问题的根源:ImageButton。 ImageButton是个很简单的控件：在普通、鼠标悬停、按下三种不同状态时显示不同的图片的按钮。 登陆页面中是这样使用ImageButton的:123....&lt;ImageButton Source=\"&#123;StaticResource SomeImage&#125;\" MouseOverImage=\"&#123;StaticResouce SomeOtherImage&#125;\" PressedImage=\"&#123;StaticResources AnotherImage&#125;\" /&gt;.... 我发现把Source=&quot;{StaticResource SomeImage}&quot;这一句去掉后程序就正常了。看来它就是罪魁祸首。为了给甩锅找个充分的理由，我把代码和相关图片资源放到新项目后，想确认的确是ImageButton导致的问题。正如下面标题剧透地，命运这次给我开了个小小的玩笑：仅包含ImageButton的代码没有问题。从现象出发的我一无所获。 第二次尝试到这里时间已经过去一个多小时了，","categories":[],"tags":[{"name":"C#,Debugging,WPF","slug":"C-Debugging-WPF","permalink":"https://verrickt.github.io/tags/C-Debugging-WPF/"}]},{"title":"闭包，变量捕获与重入问题","slug":"Closure-and-re-entrance","date":"2018-03-08T11:59:20.000Z","updated":"2018-08-02T15:07:27.730Z","comments":true,"path":"2018/03/08/Closure-and-re-entrance/","link":"","permalink":"https://verrickt.github.io/2018/03/08/Closure-and-re-entrance/","excerpt":"问题描述公司的APP，在断网后进行一个10秒的倒计时操作，每秒钟都会尝试重新联网。当秒数到0时又重新开始计时，倒计时在用户退出程序或者连上网络结束。 按理说是个很简单的Case。QA却报过来个BUG，说APP状态由 联网-&gt;断网-&gt;联网-&gt;断网 变化后，倒计时的秒数变为 9 3 8 2 7 1 变得不连续了。","text":"问题描述公司的APP，在断网后进行一个10秒的倒计时操作，每秒钟都会尝试重新联网。当秒数到0时又重新开始计时，倒计时在用户退出程序或者连上网络结束。 按理说是个很简单的Case。QA却报过来个BUG，说APP状态由 联网-&gt;断网-&gt;联网-&gt;断网 变化后，倒计时的秒数变为 9 3 8 2 7 1 变得不连续了。 思考了一下，觉得应该是第一次倒计时的没有退出，第二次倒计时开始后两者都开始更新UI。 看了代码，果然是这样的 123456789101112131415161718192021222324void OnIPChanged()&#123; ShowOfflineUI();&#125;void ShowOfflineUI()&#123; Task.Factory.Start(delegate &#123; int i = 10; while(true) &#123; i = (i-1)%10; Invoke(UpdateCountDown(i))//update UI on UI thread try &#123; Thread.Sleep(TimeSpan.FromSeconds(1)) if(Connect()) &#123; break; &#125; &#125; &#125; &#125;)&#125; 在第二次触发倒计时的时候原来的倒计时还在继续，即，两个倒计时同时执行是不安全的。这是典型的重入问题) 说实话我不是很喜欢直接用Thread.Sleep来做操作，这样占用了一个线程忙等，浪费了资源。C#中一般采用基于Task的异步编程来做，这样不会浪费资源。Task提供的CancellationToken能够比较容易的实现取消。放到这个Case里，只要开始倒计时的时候取消上一次的倒计时就好了。 说干就干,我最喜欢用Task重写基于Thread的并发/异步了 12345678910111213141516171819202122232425262728TaskCancellationToken _cts;void OnIPChanged()&#123; ShowOfflineUI(); ShowOfflineUI();&#125;async Task ShowOfflineUI()&#123; _cts?.Cancel(); _cts = new CancellationToken(); await Task.Run( async ()=&gt; &#123; int i = 0; while(true) &#123; i = (i-1)%10; Invoke(UpdateCountDown(i)); await Task.Delay(TimeSpan.FromSeconds(1),_cts.Token); if(Connect()) &#123; break; &#125; &#125; &#125; );&#125; 为了验证方法的正确性，我特地在OnIPChanged()调用了两次ShowOfflineUI()。但是第一个Task并没有被取消。 分析问题写出了跟自己预期不一样的代码怎么办？当然是上Debugger了。在Debugger的火眼金睛下，我很快注意到了最明显的现象：在第二次调用ShowOfflineUI的时候，_cts.Cancel()并没有把第一个Task中的CancellationToken的IsCancellationRequest变为True。计算机科学里有句老话，那就是永远不要怀疑近30年内编译器的正确性。经过数十分钟的排(谷)查(歌)定位了问题的原因:两个Task引用的_cts是同一个。 原因剖析如果一个匿名函数引用了不属于他自己的局部变量，那么这个现象就称为闭包。因为这实在是太自然了所以我才没往这上面想。在给Task.Run中，我传入了一个Action类型的函数，它捕获了外部变量_cts。在函数中每次用到_cts的时候，被捕获的变量的值被重新计算，结果作为实际的值。而我的本意是让两个Task拥有不同的_cts，这样后边的Task就可以取消前边的Task了。明白了这些后就很好改了，在ShowOfflineUI里放一个局部变量，存储_cts的值，让匿名函数捕获这个局部变量就好了1234567891011121314151617181920212223async Task ShowOfflineUI()&#123; var local = _cts; local?.Cancel(); _cts = new CancellationToken(); await Task.Run( async ()=&gt; &#123; int i = 0; while(true) &#123; i = (i-1)%10; Invoke(UpdateCountDown(i)); await Task.Delay(TimeSpan.FromSeconds(1),local?.Token??CancellationToken.None); if(Connect()) &#123; break; &#125; &#125; &#125; );&#125; 有兴趣的朋友可以猜一猜这两段代码的结果，再运行验证一下 123456789101112131415161718public void NonLocal()&#123; List&lt;Action&gt; actions = new List&lt;Action&gt;(); for(int i=0 ;i&lt;10;i++) actions.Add(()=&gt;Console.WriteLine(i)); actions.ForEach(a=&gt;a());&#125;public void Local()&#123; List&lt;Action&gt; actions = new List&lt;Action&gt;(); for(int i=0 ;i&lt;10;i++) &#123; int j = i; actions.Add(()=&gt;Console.WriteLine (j)); &#125; actions.ForEach(a=&gt;a());&#125; 相信名字就给大家足够多的提示了 最后祝你身体健康，再见","categories":[],"tags":[{"name":"TAP,Async/await,lambda","slug":"TAP-Async-await-lambda","permalink":"https://verrickt.github.io/tags/TAP-Async-await-lambda/"}]},{"title":"HTTPClient 踩坑记","slug":"httpclient-good-part-and-tipfalls","date":"2017-10-24T11:43:28.000Z","updated":"2018-08-02T15:04:19.455Z","comments":true,"path":"2017/10/24/httpclient-good-part-and-tipfalls/","link":"","permalink":"https://verrickt.github.io/2017/10/24/httpclient-good-part-and-tipfalls/","excerpt":"HttpClient是随着.Net framework 4.5一起发布的现代Http库。比起WebClient，HttpClient最大的优点就是加入了C#5中的async/await异步方法的支持。async/await的坑暂且不表，今天就来说一说这个HttpClient HttpClient的坑HttpClient实现了IDisposable接口，很多小伙伴一看到IDisposeable接口就纷纷把HttpClient套在了using里边 12345//bad httpclient usageusing(var client = new HttpClient())&#123; //do stuffs&#125; 这种用法是错误的.HttpClient在设计之初被设计为一个可重用的对象，它的生命周期应该与应用程序相一致.上述错误的用法每发起一个请求就会创建一个新的HttpClient，并且在收到回复之后立即把HttpClient dispose掉。众所周知TCP连接在真正断开之前会有几分钟处于CLOSE_WAIT状态。这个状态下TCP链接并没有真正断开。短时间内大量发出Http请求会使系统可用的端口急剧消耗。","text":"HttpClient是随着.Net framework 4.5一起发布的现代Http库。比起WebClient，HttpClient最大的优点就是加入了C#5中的async/await异步方法的支持。async/await的坑暂且不表，今天就来说一说这个HttpClient HttpClient的坑HttpClient实现了IDisposable接口，很多小伙伴一看到IDisposeable接口就纷纷把HttpClient套在了using里边 12345//bad httpclient usageusing(var client = new HttpClient())&#123; //do stuffs&#125; 这种用法是错误的.HttpClient在设计之初被设计为一个可重用的对象，它的生命周期应该与应用程序相一致.上述错误的用法每发起一个请求就会创建一个新的HttpClient，并且在收到回复之后立即把HttpClient dispose掉。众所周知TCP连接在真正断开之前会有几分钟处于CLOSE_WAIT状态。这个状态下TCP链接并没有真正断开。短时间内大量发出Http请求会使系统可用的端口急剧消耗。 MS的人推荐重用HttpClient以使其生命周期与应用相同 1234567891011//good httpclient usageclass GoodHttpClientSample&#123; private static readonly HttpClient client = new HttpClient(); public Task&lt;string&gt; GetStringAsync(string url) &#123; var resposne = await client.GetAsync(url).ConfigureAwait(false); return response.Content.ReadAsStringAsync(); &#125; &#125; HttpClient的优点踩过了坑我们再来说说他的好处。去掉async/await支持这个最大的有点，HttpClient的一个构造函数的重载接受一个HttpMessageHandler。这个重载很有意思。HttpMessageHandler可以在发出Http请求和接受Http回复时做出一些回应。.net framework里有一个类叫做DelegatingHandler，它继承了HttpMessageHandler。叫做DelegatingHandler是因为它有个类型为HttpMessageHandler的InnerHandler属性，因而可以把请求delegate给InnerHandler。通过这个DelegatingHandler我们可以请以实现像Java web里的filter chain一样的逻辑。 今天重构了公司的代码。公司现有的HttpManager提供了GET和POST两种Http动词的异步方法。在这些方法中还进行了日志记录和失败重试。日志记录和失败重试相关的代码非常重复，但是又无法写成一个函数。因此我把这部分逻辑抽出来做成了两个DelegatingHandler 12345678910111213141516171819202122232425class LogHandler:DelegatingHandler&#123; private readonly ILog _log; public LogHandler(ILog log,HttpMessageHandler handler):base(handler) &#123; _log = log; &#125; protected async override Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) &#123; try &#123; var begin = DateTime.Now; _log.I($\"&#123;request.Method&#125; -&gt;&#123;request.RequestUri&#125;\"); var response = await base.SendAsync(request,cancellationToken); var end = DateTime.Now; var diff = (end-begin).TotalMillseconds; _log.I($\"&#123;request.Method&#125; &lt;- &#123;response.Content.ReadAsStringAsync()&#125; cost&#123;diff&#125;ms\"); &#125; catch(Exception e) &#123; _log.E($\"&#123;request.Method&#125; -&gt;&#123;request.RequestUri&#125;,&#123;e&#125;\"); throw; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435class RetryHandler:DelegatingHandler&#123; protected async override Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request,CancellationToken cancellationToken) &#123; HttpResponseMessage response = null; for(int i=0;i&lt;=_retryTimes,i++) &#123; try &#123; response = await base.SendAsync(request,cancellationToken); return response; &#125; catch(Exception) &#123; if(i==_retryTimes) &#123; throw; &#125; &#125; //make compiler happy. return response; &#125; &#125; private readonly int _retryTimes = 0; public RetryHandler(int retryTimes,HttpMessageHandler handler):base(handler) &#123; if(retryTimes&lt;0) &#123; throw new ArgumentOutOfRangeException(nameof(retryTimes)); &#125; _retryTimes = retryTimes; &#125;&#125; HttpClientHandler是个真正实现HttpClient逻辑的HttpMessageHandler。因此，我们只要保证最内部的Handler时HttpClientHandler就OK了。 1234private static readonly ILog _log;private static readonly HttpClient _client = new HttpClient(new RetryHandler(3,new LogHandler(_log,new HttpClientHandler()))); 需要注意的是，如果HttpHandler没有返回HttpResponseMessage,对应的异步方法会在运行时抛出InvalidOperationException 重构之后整个Http封装类的代码行数从400行减少到了120行左右，可读性和可维护性提升显著。 Further readingFUN WITH THE HTTPCLIENT PIPELINE YOU’RE USING HTTPCLIENT WRONG AND IT IS DESTABILIZING YOUR SOFTWARE Do HttpClient and HttpClientHandler have to be disposed?","categories":[],"tags":[{"name":"HttpClient","slug":"HttpClient","permalink":"https://verrickt.github.io/tags/HttpClient/"},{"name":"C#","slug":"C","permalink":"https://verrickt.github.io/tags/C/"}]}]}