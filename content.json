{"meta":{"title":"Melchior on CLR","subtitle":"Verrickt as a Programmer","description":"A programmer focus mainly on Microsoft Technologies","author":"Verrickt","url":"https://verrickt.github.io"},"pages":[],"posts":[{"title":"HTTPClient 踩坑记","slug":"httpclient-good-part-and-tipfalls","date":"2017-10-24T11:43:28.000Z","updated":"2017-10-25T13:57:17.740Z","comments":true,"path":"2017/10/24/httpclient-good-part-and-tipfalls/","link":"","permalink":"https://verrickt.github.io/2017/10/24/httpclient-good-part-and-tipfalls/","excerpt":"HttpClient是随着.Net framework 4.5一起发布的现代Http库。比起WebClient，HttpClient最大的优点就是加入了C#5中的async/await异步方法的支持。async/await的坑暂且不表，今天就来说一说这个HttpClient HttpClient的坑HttpClient实现了IDisposable接口，很多小伙伴一看到IDisposeable接口就纷纷把HttpClient套在了using里边 12345//bad httpclient usageusing(var client = new HttpClient())&#123; //do stuffs&#125; 这种用法是错误的.HttpClient在设计之初被设计为一个可重用的对象，它的生命周期应该与应用程序相一致.上述错误的用法每发起一个请求就会创建一个新的HttpClient，并且在收到回复之后立即把HttpClient dispose掉。众所周知TCP连接在真正断开之前会有几分钟处于CLOSE_WAIT状态。这个状态下TCP链接并没有真正断开。短时间内大量发出Http请求会使系统可用的端口急剧消耗。","text":"HttpClient是随着.Net framework 4.5一起发布的现代Http库。比起WebClient，HttpClient最大的优点就是加入了C#5中的async/await异步方法的支持。async/await的坑暂且不表，今天就来说一说这个HttpClient HttpClient的坑HttpClient实现了IDisposable接口，很多小伙伴一看到IDisposeable接口就纷纷把HttpClient套在了using里边 12345//bad httpclient usageusing(var client = new HttpClient())&#123; //do stuffs&#125; 这种用法是错误的.HttpClient在设计之初被设计为一个可重用的对象，它的生命周期应该与应用程序相一致.上述错误的用法每发起一个请求就会创建一个新的HttpClient，并且在收到回复之后立即把HttpClient dispose掉。众所周知TCP连接在真正断开之前会有几分钟处于CLOSE_WAIT状态。这个状态下TCP链接并没有真正断开。短时间内大量发出Http请求会使系统可用的端口急剧消耗。 MS的人推荐重用HttpClient以使其生命周期与应用相同 1234567891011//good httpclient usageclass GoodHttpClientSample&#123; private static readonly HttpClient client = new HttpClient(); public Task&lt;string&gt; GetStringAsync(string url) &#123; var resposne = await client.GetAsync(url).ConfigureAwait(false); return response.Content.ReadAsStringAsync(); &#125; &#125; HttpClient的优点踩过了坑我们再来说说他的好处。去掉async/await支持这个最大的有点，HttpClient的一个构造函数的重载接受一个HttpMessageHandler。这个重载很有意思。HttpMessageHandler可以在发出Http请求和接受Http回复时做出一些回应。.net framework里有一个类叫做DelegatingHandler，它继承了HttpMessageHandler。叫做DelegatingHandler是因为它有个类型为HttpMessageHandler的InnerHandler属性，因而可以把请求delegate给InnerHandler。通过这个DelegatingHandler我们可以请以实现像Java web里的filter chain一样的逻辑。 今天重构了公司的代码。公司现有的HttpManager提供了GET和POST两种Http动词的异步方法。在这些方法中还进行了日志记录和失败重试。日志记录和失败重试相关的代码非常重复，但是又无法写成一个函数。因此我把这部分逻辑抽出来做成了两个DelegatingHandler 12345678910111213141516171819202122232425class LogHandler:DelegatingHandler&#123; private readonly ILog _log; public LogHandler(ILog log,HttpMessageHandler handler):base(handler) &#123; _log = log; &#125; protected async override Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) &#123; try &#123; var begin = DateTime.Now; _log.I($\"&#123;request.Method&#125; -&gt;&#123;request.RequestUri&#125;\"); var response = await base.SendAsync(request,cancellationToken); var end = DateTime.Now; var diff = (end-begin).TotalMillseconds; _log.I($\"&#123;request.Method&#125; &lt;- &#123;response.Content.ReadAsStringAsync()&#125; cost&#123;diff&#125;ms\"); &#125; catch(Exception e) &#123; _log.E($\"&#123;request.Method&#125; -&gt;&#123;request.RequestUri&#125;,&#123;e&#125;\"); throw; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435class RetryHandler:DelegatingHandler&#123; protected async override Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request,CancellationToken cancellationToken) &#123; HttpResponseMessage response = null; for(int i=0;i&lt;=_retryTimes,i++) &#123; try &#123; response = await base.SendAsync(request,cancellationToken); return response; &#125; catch(Exception) &#123; if(i==_retryTimes) &#123; throw; &#125; &#125; //make compiler happy. return response; &#125; &#125; private readonly int _retryTimes = 0; public RetryHandler(int retryTimes,HttpMessageHandler handler):base(handler) &#123; if(retryTimes&lt;0) &#123; throw new ArgumentOutOfRangeException(nameof(retryTimes)); &#125; _retryTimes = retryTimes; &#125;&#125; HttpClientHandler是个真正实现HttpClient逻辑的HttpMessageHandler。因此，我们只要保证最内部的Handler时HttpClientHandler就OK了。 1234private static readonly ILog _log;private static readonly HttpClient _client = new HttpClient(new RetryHandler(3,new LogHandler(_log,new HttpClientHandler()))); 需要注意的是，如果HttpHandler没有返回HttpResponseMessage,对应的异步方法会在运行时抛出InvalidOperationException 重构之后整个Http封装类的代码行数从400行减少到了120行左右，可读性和可维护性提升显著。 Further readingFUN WITH THE HTTPCLIENT PIPELINE YOU’RE USING HTTPCLIENT WRONG AND IT IS DESTABILIZING YOUR SOFTWARE Do HttpClient and HttpClientHandler have to be disposed?","categories":[],"tags":[{"name":"HttpClient","slug":"HttpClient","permalink":"https://verrickt.github.io/tags/HttpClient/"},{"name":"C#","slug":"C","permalink":"https://verrickt.github.io/tags/C/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-09-18T13:40:28.284Z","updated":"2017-09-18T13:40:28.285Z","comments":true,"path":"2017/09/18/hello-world/","link":"","permalink":"https://verrickt.github.io/2017/09/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}